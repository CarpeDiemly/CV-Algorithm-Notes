[参考链接](https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%A7%8D%E7%B1%BB)

##  一、二叉树种类

### 主要分类

#### 满二叉树

所有节点都满了（深度为k，有2^k-1个节点的二叉树）

####  完全二叉树

除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。

### 其他分类

#### 二叉搜索树

前面树没有数值（是秃的），有了数值（树叶）便是**二叉搜索树**，它是一个有序树。

- 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值（左小上）
- 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值（右大上）
- 它的左、右子树也分别为**二叉排序树**

#### 平衡二叉搜索树

满足以下性质：

- 它是一棵空树或它的左右两个子树的高度差的绝对值不超过1
- 左右两个子树都是一棵平衡二叉树

注：**C++中map、set、multimap，multiset的底层实现都是平衡二叉搜索树**，所以map、set的增删操作时间时间复杂度是logn。

## 存储方式

**可以顺序存储，也可链式存储**

**顺序存储**

元素在内存是连续分布的

实现方式：数组

遍历：如果父节点的数组下标是 i，那么它的左孩子就是 i \* 2 + 1，右孩子就是 i \* 2 + 2。

**链式存储**

通过指针把分布在散落在各个地址的节点串联一起。

实现方式：指针



### 遍历方式

主要用两种方式：

1. 深度优先：先往深处走，遇到子节点再往回走

   - 前序遍历（递归法，迭代法）： 中左右

     中指的是中间的节点，所谓节点是下面还有分支的点，这样把没处节点看做一个整体,走这个顺序

   - 中序遍历（递归法，迭代法）：左中右

   - 后序遍历（递归法，迭代法）：左右中

2. 广度优先：一层一层遍历

   - 层次遍历（迭代法）

![image-20220507091230703](https://raw.githubusercontent.com/kongyan66/Img-for-md/master/img/image-20220507091230703.png)

**说到二叉树，就不得不说递归，很多同学对递归都是又熟悉又陌生，递归的代码一般很简短，但每次都是一看就会，一写就废。**

## 二、二叉树递归遍历

### 2.1 怎么写好递归？

按照三个要素来写：

1. **确定递归函数的参数和返回值**：确定哪些参数是递归过程需要处理的，那就在递归函数里加上这个参数，并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型。
2. **确定终止条件**：运行的时候经常遇到栈溢出，就是没写终止条件或是写的不对，操作系统就是用一个栈的结构保存每一层的信息，如递归没有终止，栈必然溢出。
3. **确定单层递归的逻辑**：确定每一层要处理的信息逻辑。

###  2.2 前序递归遍历

1. 确定递归的参数和返回值

   因为要打印出前序遍历的节点的数值，所以参数需要传入一个列表，不需要返回任何值，故：

   ```python
   def traversal(treenode, result)
   ```

2. 确定终止条件

   什么时候递归结束了呢？当然是当前遍历的节点空了，那么本层递归就结束了。

   ```pyhton 
   if cur == None: return
   ```

3. 确定单层递归的逻辑

   前序遍历是中左右的循环，所以在单层的逻辑是，先获取中节点的值，再是左和右： 

   ```python
   result.append(treenode.val)
   traversal(treenode.left)
   traversal(treenode.right)
   ```

   

​       

 