[参考链接](https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%A7%8D%E7%B1%BB)

##  一、二叉树定义及分类

### 1.1 定义

#### 理论定义

是每个节点最多只有两个分支（即不存在分支度大于2的节点）的一种树型结构（外观像嘛）。

树表示由边连接的节点。它是一个非线性的数据结构。它具有以下特性。

1. 一个节点被标记为根节点。
2. 除根节点之外的每个节点都与一个父节点关联。
3. 每个节点可以有一个arbiatry编号的chid节点

单节点链表是一个，树是两个，两者实现上没太大区别，性质区别大。

<img src="https://raw.githubusercontent.com/kongyan66/Img-for-md/master/img/image-20220508105538765.png" alt="image-20220508105538765" style="zoom:67%;" />

#### **代码定义**

这里当然不能定义整个树，而是树的节点，节点构成一颗树

**C++版本**

当然用C++定义是最原汁原味了， c++使用struct去定义：

```C++
// 定义树的节点
struct TreeNode {
    int val;           //节点的数据类型
    TreeNode *left;    // 左子树
    TreeNode *right;   // 右子树
    TreeNode(int x) 
    {
        val = x;
        left = NULL;
        right = NULL；
    }
}TreeNode, *TreeNode;
```

**python版本**  

python 使用对象去定义，这也是python最常用的数据机构定义手段了（链表也是）

这里我们创建一个**节点类**，赋值后就变成了一个只有根节点的树了（最小的树）

```python 
class TreeNode:
    def __init__(self, val):
        self.val = val    # 当前节点的值
        self.left = None  # 下一个节点的地址
        self.right = None # 下一个节点的地址
root = TreeNode(10)
```



### 1.2 主要分类

#### 满二叉树

所有节点都满了（深度为k，有2^k-1个节点的二叉树）

####  完全二叉树

除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。

### 1.3 其他分类

#### 二叉搜索树

前面树没有数值（是秃的），有了数值（树叶）便是**二叉搜索树**，它是一个有序树。

- 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值（左小上）
- 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值（右大上）
- 它的左、右子树也分别为**二叉排序树**

#### 平衡二叉搜索树

满足以下性质：

- 它是一棵空树或它的左右两个子树的高度差的绝对值不超过1
- 左右两个子树都是一棵平衡二叉树

注：**C++中map、set、multimap，multiset的底层实现都是平衡二叉搜索树**，所以map、set的增删操作时间时间复杂度是logn。

## 二 、存储方式

**可以顺序存储，也可链式存储**， 可见数据结构并不是底层容器，只是数据按照某种规则排列起来，不限制于底层容器。

**顺序存储**

元素在内存是连续分布的

实现方式：数组

遍历：如果父节点的数组下标是 i，那么它的左孩子就是 i \* 2 + 1，右孩子就是 i \* 2 + 2。

**链式存储**

通过指针把分布在散落在各个地址的节点串联一起。

实现方式：指针



## 三、遍历方式

主要用两种方式：

1. 深度优先(DFS)：先往深处走，遇到子节点再往回走

   - 前序遍历（递归法，迭代法）： 中左右

     中指的是中间的节点，所谓节点是下面还有分支的点，这样把没处节点看做一个整体,走这个顺序

   - 中序遍历（递归法，迭代法）：左中右

   - 后序遍历（递归法，迭代法）：左右中

2. 广度优先：一层一层遍历,直到最底层

   - 层次遍历(BFS)
     迭代法、递归法

![image-20220507091230703](https://raw.githubusercontent.com/kongyan66/Img-for-md/master/img/image-20220507091230703.png)

**说到二叉树，就不得不说递归，很多同学对递归都是又熟悉又陌生，递归的代码一般很简短，但每次都是一看就会，一写就废。**

## 四、二叉树递归遍历

### 2.1 怎么写好递归？

按照三个要素来写：

1. **确定递归函数的参数和返回值**：确定哪些参数是递归过程需要处理的，那就在递归函数里加上这个参数，并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型。
2. **确定终止条件**：运行的时候经常遇到栈溢出，就是没写终止条件或是写的不对，操作系统就是用一个栈的结构保存每一层的信息，如递归没有终止，栈必然溢出。
3. **确定单层递归的逻辑**：确定每一层要处理的信息逻辑。

###  2.2 前序递归遍历

1. 确定递归的参数和返回值

   因为要打印出前序遍历的节点的数值，所以参数需要传入一个列表，不需要返回任何值，故：

   ```python
   def traversal(treenode, result)
   ```

2. 确定终止条件

   什么时候递归结束了呢？当然是当前遍历的节点空了，那么本层递归就结束了。

   ```pyhton 
   if cur == None: return
   ```

3. 确定单层递归的逻辑

   前序遍历是中左右的循环，所以在单层的逻辑是，先获取中节点的值，再是左和右： 

   ```python
   result.append(treenode.val)
   traversal(treenode.left)
   traversal(treenode.right)
   ```


## 五、 二叉树迭代遍历

​       迭代遍历借助栈和指针实现，指针实现具体节点的定位，栈用于保存路径，整个过程还是十分巧妙的，下面以中序遍历为例：

<img src="https://raw.githubusercontent.com/kongyan66/Img-for-md/master/img/image-20220508164516952.png" alt="image-20220508164516952" style="zoom: 67%;" />

 