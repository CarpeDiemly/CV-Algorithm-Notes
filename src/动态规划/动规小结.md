

## 问题

动规可以说是最优问题的常客了，究竟哪些题能用上动规，如何将问题转换为一个动规问题，同时动规的状态转移方程推导思路，都需要一一弄明白。

## 动规思想来源

动态规划的核心设计思想是数学归纳法。

相信大家对数学归纳法都不陌生，高中就学过，而且思路很简单。比如我们想证明一个数学结论，那么**我们先假设这个结论在 `k < n` 时成立，然后根据这个假设，想办法推导证明出 `k = n` 的时候此结论也成立**。如果能够证明出来，那么就说明这个结论对于 `k` 等于任何数都成立。

类似的，我们设计动态规划算法，不是需要一个 dp 数组吗？我们可以假设 `dp[0...i-1]` 都已经被算出来了，然后问自己：怎么通过这些结果算出 `dp[i]`？

直接拿最长递增子序列这个问题举例你就明白了。不过，首先要定义清楚 dp 数组的含义，即 `dp[i]` 的值到底代表着什么？



**下面以[300.最长递增子序列](https://leetcode.cn/problems/longest-increasing-subsequence/)为例说明下这个思想：**

**我们定义：`dp[i]` 表示以 `nums[i]` 这个数结尾的最长递增子序列的长度**。

> PS：为什么这样定义呢？这是解决子序列问题的一个套路，后文 [动态规划之子序列问题解题模板](https://labuladong.github.io/algo/3/26/79/) 总结了几种常见套路。你读完本章所有的动态规划问题，就会发现 `dp` 数组的定义方法也就那几种。

**假设我们已经知道了 `dp[0..4]` 的所有结果，我们如何通过这些已知结果推出 `dp[5]` 呢**？

<img src="https://raw.githubusercontent.com/kongyan66/Img-for-md/master/img/6.jpeg" alt="img" style="zoom:50%;" />

根据刚才我们对 `dp` 数组的定义，现在想求 `dp[5]` 的值，也就是想求以 `nums[5]` 为结尾的最长递增子序列。

**`nums[5] = 3`，既然是递增子序列，我们只要找到前面那些结尾比 3 小的子序列，然后把 3 接到这些子序列末尾，就可以形成一个新的递增子序列，而且这个新的子序列长度加一**。

`nums[5]` 前面有哪些元素小于 `nums[5]`？这个好算，用 for 循环比较一波就能把这些元素找出来。

以这些元素为结尾的最长递增子序列的长度是多少？回顾一下我们对 `dp` 数组的定义，它记录的正是以每个元素为末尾的最长递增子序列的长度。

以我们举的例子来说，`nums[0]` 和 `nums[4]` 都是小于 `nums[5]` 的，然后对比 `dp[0]` 和 `dp[4]` 的值，我们让 `nums[5]` 和更长的递增子序列结合，得出 `dp[5] = 3`：

<img src="https://raw.githubusercontent.com/kongyan66/Img-for-md/master/img/7.jpeg" alt="img" style="zoom:50%;" />

## 参考

- [labuladong 动态规划结题套路框架](https://labuladong.github.io/algo/3/25/69/)
- [一文吃透背包问题](https://leetcode.cn/problems/last-stone-weight-ii/solution/yi-pian-wen-zhang-chi-tou-bei-bao-wen-ti-5lfv/)
- [背包规律小结](https://leetcode.cn/problems/combination-sum-iv/solution/xi-wang-yong-yi-chong-gui-lu-gao-ding-bei-bao-wen-/)