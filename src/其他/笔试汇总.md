# 笔试汇总(暂时保密)
## 8-31 广联达
选择20 编程2  90分钟  赛马平台(可修改)

[牛客解答](https://www.nowcoder.com/discuss/1035451?type=all&order=recall&pos=&page=1&ncTraceId=&channel=-1&source_id=search_all_nctrack&gio_id=24610FBF80DDDDA0184C47CB8997DF97-1662017972306)

### 题一：异常数组

自己仅仅AC27

<img src="https://raw.githubusercontent.com/kongyan66/Img-for-md/master/img/image-20220901163738379.png" alt="image-20220901163738379" style="zoom: 67%;" />

**考察**：最长升序子序列

**思路**：

直接对s编号然后在p里面求最长上升子序列的长度l，然后认为答案等于len(p)-l这种做法是错误的，可以看以下样例：

```python
input：
5
1 2 3 4 5
3 4 5 1 2
output:
3
```

如果只是求最长上升子序列的话，那就默认了存在减速的情况与题目说的只存在加速的情况矛盾(没理解这句话)

**代码**：

```python
arra = [5, 4, 3, 2, 1]
arrb = [1, 5, 3, 4, 2]  # 排序错误个数为2
idx = {v:i for i, v in enumerate(arrb)}
last = -1
ans = 0
# 求最大的上升序列l
for v in arra:
    if last < idx[v]:
        last = idx[v]
    else:
        ans += 1
print(ans)
```



### 题目二：最多的人

![image-20220901165402546](https://raw.githubusercontent.com/kongyan66/Img-for-md/master/img/image-20220901165402546.png)

**考察：**贪心

**思路**：



**代码**：

```python
n,m=map(int,input().split())
G=[[] for i in range(n+1)]
for i in range(m):
    l,r,x=map(int,input().split())
    G[l-1].append((r,x))
for i in range(1,n+1):
    G[i-1].append((i,1))
    G[i].append((i-1,0))
dis=[float('inf')]*(n+1)
dis[0]=0
que=[]
que.append((0,0))
while que:
    cost,u=heapq.heappop(que)
    for v,w in G[u]:
        if dis[v]>dis[u]+w:
            dis[v]=dis[u]+w
            heapq.heappush(que,(dis[v],v))
print(dis[-1])
```

**小技巧**：

真不会，就猜输出，骗分。比如输出8能过18%，输出n-2就能过36%了，总比0分强吧！



## 9-01 深信服

选择10 填空5 编程3  120分钟   总分100 牛客平台(不可修改，有终端输出，可以预览题目)

[牛客题解](https://www.nowcoder.com/discuss/1036854?type=post&order=recall&pos=&page=1&ncTraceId=&channel=-1&source_id=search_post_nctrack&gio_id=24610FBF80DDDDA0184C47CB8997DF97-1662106799638)

### 题目一：日志分析

输入：第一行正整数T，紧接着T行字符串

输出：T行，每个日志潜在的攻击次数，结果对1e9+7取模

求攻击次数，就是计算swr子序列个数（子串是可以是不连续的字符串，但是保持前后字符顺序）

<img src="https://raw.githubusercontent.com/kongyan66/Img-for-md/master/img/image-20220902195711610.png" alt="image-20220902195711610" style="zoom: 80%;" />

**思路**：只需要遍历每个w，统计每个w前s的个数，和每个w后r的个数，然后相乘，加到最后结果里面也就是分别统计从0到第i位，有几个s，从最后一位到第i位，有几个r.

**编程：**

```python
s = 'wsswrrw'
mod =  1e9 + 7 
s_left = [0] * len(s)
r_right = [0] * len(s)

w_inx = []
res = 0
for i in range(len(s)):
    if s[i] == "s":
        s_left[i] = 1
    if s[i] == "r":
        r_right[i] = 1
        
    if s[i] == "w":
        w_inx.append(i)

for i  in range(len(w_inx)):
    index = w_inx[i]
    res += sum(s_left[:index]) * sum(r_right[index+1:])
print(res % mod)
```

### 题目二：旅游人数

<img src="https://raw.githubusercontent.com/kongyan66/Img-for-md/master/img/image-20220902202749630.png" alt="image-20220902202749630" style="zoom: 80%;" />

**题意分析**

输入：T表示组数，n表示一共有n个员工，每个员工有特定的时间段，之后是n行，[a,b]表示一位员工方便旅游的时间段

输出：每一组同时让员工觉得方便的最大人数，就是输出某个时间方便人数最多的数量。





### 题目三：五进制模拟

![image-20220902204649608](https://raw.githubusercontent.com/kongyan66/Img-for-md/master/img/image-20220902204649608.png)

**题意分析**

输入：字符串或数字 五进制用字符串表示

输出：对应的十进制或五进制

**思路**

判断输入类型，数字就转五进制，字符串就转十进制

还需要用连个map做字母与数字的映射

**代码**

```python
str_map = {'0':0, 'y':1, 'e':2, 'a':3, 's':4}
nums_map = {v: k for k, v in str_map.items()}
# 十进制转5进制
def ten2five(n, x):
    b = []
    ans = ''
    while True:
        s = n // x # 求商
        y = n % x  # 求余
        b.append(y)
        if s == 0:
            break
        n = s
    b.reverse()
    for num in b:
        ans += nums_map[num]
    return ans
# 5进制转十进制
def five2ten(s, x):
    b = []
    ans = 0
    for i in range(len(s)):
        b.append(str_map[s[i]])
    b.reverse()
    for i in range(len(b)):
        ans += b[i] * x**i
    return ans

if __name__ == '__main__':  
    # input = ‘aya'
    input = 3958  
    if isinstance(input, int):
        ans = ten2five(input, 5)
        print(ans)
    else:
        ans = five2ten(input, 5)
        print(ans)
```



## 9-03 美团

### 题目一：乒乓球

甲乙两人打乒乓球，已知甲乙的得分，获胜条件时得分至少为11分且领先一方2分, 问甲获胜需要再得多少分？

### 题目二：mex值

给一个非负序列（无重复） ，求不属于该序列的最小非负整数

### 题目三：字母树

<img src="https://raw.githubusercontent.com/kongyan66/Img-for-md/master/img/image-20220903202103257.png" alt="image-20220903202103257" style="zoom:67%;" />

**题意分析**：

此题思路容易，难在怎么构建表示这棵树，二叉树中是用节点构建一棵树，这里可以用字典来表示层次关系，所以输入第二行数据的分析很关键，还有就是如何对字典树进行递归遍历了。

**思路**：

对字典树后续遍历，用set(去重)保存每个节点的路径

**代码**：

```python 
from collections import defaultdict


def postorder(root, id):
    # 保存遍历路径，用set去重
    res = set()
    # 单层递归逻辑（不太好理解）
    for  idx in root[id]:
        res.update(postorder(root, idx))  # 更新元组，相当于extend()
    # 后续遍历
    res.add(char_map[id])  # 更新元组，相当于append()
    # 保存每个节点对应的路径
    ans[id] = res
    return res

if __name__ == '__main__':
    # 输入数据
    n = 6
    nums = [1,2, 2, 1, 4]
    chars = "ABCCAD"
    # 节点与字符的映射
    char_map = {}
    for idx,c in enumerate(chars):
        char_map[idx+1] = c

    # 这一步转换很精妙呀，用字典作记录一棵树，key为父节点，value为子节点， 通过nums的值和index+2分别找出
    trees = defaultdict(list)
    for idx, v in enumerate(nums):
        trees[v].append(idx+2)

    ans = defaultdict(set)

    # 字典树的后续遍历
    postorder(trees, 1)

    # 转换为最终结果
    ans = [str(len(ans[n+1])) for n in range(n)]
    print(' '.join(ans))
```

### 题目四：任务

<img src="https://raw.githubusercontent.com/kongyan66/Img-for-md/master/img/image-20220904214712755.png" alt="image-20220904214712755" style="zoom:67%;" />





