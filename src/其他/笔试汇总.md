# 笔试汇总(暂时保密)
## 8-31 广联达
选择20 编程2  90分钟  赛马平台(可修改)

[牛客解答](https://www.nowcoder.com/discuss/1035451?type=all&order=recall&pos=&page=1&ncTraceId=&channel=-1&source_id=search_all_nctrack&gio_id=24610FBF80DDDDA0184C47CB8997DF97-1662017972306)

### 题一：异常数组

自己仅仅AC27

<img src="https://raw.githubusercontent.com/kongyan66/Img-for-md/master/img/image-20220901163738379.png" alt="image-20220901163738379" style="zoom: 67%;" />

**考察**：最长升序子序列

**思路**：

直接对s编号然后在p里面求最长上升子序列的长度l，然后认为答案等于len(p)-l这种做法是错误的，可以看以下样例：

```python
input：
5
1 2 3 4 5
3 4 5 1 2
output:
3
```

如果只是求最长上升子序列的话，那就默认了存在减速的情况与题目说的只存在加速的情况矛盾(没理解这句话)

**代码**：

```python
arra = [5, 4, 3, 2, 1]
arrb = [1, 5, 3, 4, 2]  # 排序错误个数为2
idx = {v:i for i, v in enumerate(arrb)}
last = -1
ans = 0
# 求最大的上升序列l
for v in arra:
    if last < idx[v]:
        last = idx[v]
    else:
        ans += 1
print(ans)
```



### 题目二：最多的人

![image-20220901165402546](https://raw.githubusercontent.com/kongyan66/Img-for-md/master/img/image-20220901165402546.png)

**考察：**贪心

**思路**：



**代码**：

```python
n,m=map(int,input().split())
G=[[] for i in range(n+1)]
for i in range(m):
    l,r,x=map(int,input().split())
    G[l-1].append((r,x))
for i in range(1,n+1):
    G[i-1].append((i,1))
    G[i].append((i-1,0))
dis=[float('inf')]*(n+1)
dis[0]=0
que=[]
que.append((0,0))
while que:
    cost,u=heapq.heappop(que)
    for v,w in G[u]:
        if dis[v]>dis[u]+w:
            dis[v]=dis[u]+w
            heapq.heappush(que,(dis[v],v))
print(dis[-1])
```

**小技巧**：

真不会，就猜输出，骗分。比如输出8能过18%，输出n-2就能过36%了，总比0分强吧！

