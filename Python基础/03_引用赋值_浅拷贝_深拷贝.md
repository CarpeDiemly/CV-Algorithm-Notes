## 问题

## 概述

之前都不知道一个变量赋值需要考虑这么多（ps:说明变量用的太简单了），直到在刷题中遇到BUG（回溯得到的路径为空），才知道针对于组合变量与非组合变量，其赋值是有区别的，下面就深入谈谈吧！

## 引用与赋值

### 基本变量赋值

在python中，使用等号无论是直接的`变量赋值`，还是`参数传递`，都是按照`引用进行赋值`的，`等号赋值`是指将对象的`内存指针赋值`。

在Python中对于非组合变量（对象中不包含其他对象，只有一层地址关系）的赋值直接使用等号赋值即可，即将一个变量赋值给另一个变量，则两者不仅在数值上相等，而且还是`同一对象`，`id相同`，`is判断为True`，**这两个变量都指向这一个数据对象**，即这个数据对象**有两个引用**，只有这两个引用都没了的时候，堆内存中的数据对象才会等待垃圾回收器回收。

```python
>>> # 将一个变量赋值给另一个变量
>>> a = 10000
>>> b = a
>>> id(a)
140139864296144
>>> id(b)
140139864296144
>>> a is b
True
```

如果`单独对两个变量赋值`，就算赋值的数据对象相同，也只是数据对象的值相等，两个变量在堆内存中是`不同的对象`。

```pyhton
>>> a = 10000
>>> b = 10000
>>> id(a)
140139864296272
>>> id(b)
140139864296048
>>> a is b
False
```

### 可变对象，不可变对象对引用赋值的影响

**不可变对象**

如果变量的值是不可变对象，比如string，int，float，tuple等，`其中一个变量重新赋值`意味着在内存中要`新创建一个数据对象`，此时`变量间不会相互影响`，即不会影响另外一个变量。

```python
>>> a = 10000
>>> b = a
>>> id(a)
140139864296272
>>> id(b)
140139864296272
>>> a = 20000  # 改变a的值
>>> id(a)  # a在堆内存中新创建了一个对象，获得新的id地址
140139864295920
>>> b  # b不变
10000
```

![img](https://raw.githubusercontent.com/kongyan66/Img-for-md/master/img/22206660-5de1f554c274b48e.png)

​                                      																	不可变对象赋值引用改变变量值

**可变对象**

对于可变对象，**调用自身方法使的值改变不会改变内存地址**。比如列表list，字典dict，集合set，如果是在原数据对象自身上做修改，比如`修改列表中的某个元素`，列表的`地址不会变`，还是原来的那个内存对象，此时调用另一个变量的值也会改变，因为是同一个内存对象的两个引用，因此对于`可变对象的引用赋值`，变量之间是`相互影响`的。

```python
>>> a = {"a": 1, "b": 3}
>>> b = a
>>> b["c"] = 9  # 改变其中一个变量，给字典新增一个值
>>> a  # 原始变量也会收到影响
{'a': 1, 'b': 3, 'c': 9}
>>> id(a)
140139842087104
>>> id(b)
140139842087104  # 内存地址未改变，只是新增了一个元素
```

![img](https://raw.githubusercontent.com/kongyan66/Img-for-md/master/img/22206660-439eb0995e625bdb.png)

​																													可变对象赋值引用改变变量值

### 缓存的重用机制

Python会根据对象的`读取频繁程度`以及`内存占用情况`，按照一定规则将`对象存入缓存`。当程序的其他代码使用这些值的时候，会先去缓存中找并且直接引用缓存中的地址，不需要额外创建，这些值包括：`[-5, 256]之间的小整数`，`字符串对象`。

```ruby
>>> a = -3
>>> b = -3
>>> a is b
True
>>> b = 2234 - 2237
>>> a is b
True
```

超过256分别赋值就是不同对象了！

```python
>>> a = 257
>>> b = 257
>>> a is b
False
```

**字符串是直接读取缓存中地址**.

```ruby
>>> a = "aaaabbbbcccc"
>>> b = "aaaabbbbcccc"
>>> a is b
True
```

除此之外，其他`不可变变量`如果`处在同一个代码块`或者`同行`，也直接获取代码块中缓存的变量，`不再另外创建`.

不可变量同一行的情况：

```python
>>> # 同行
>>> a = 20000; b = 20000
>>> a is b
True
>>> a = 20000
>>> b = 20000
>>> a is b
False
```

同一个函数代码块的情况：

```python
>>> def a():
...     a = -2836755.383274835
...     b = -2836755.383274835
...     print(a is b)
...     print(id(a))
...     print(id(b))
... 
>>> a()
True
140139864296112
140139864296112
```





## 深拷贝与浅拷贝

首先深拷贝和浅拷贝是`针对组合对象`的，组合对象就是这个`对象中还包含其他对象`，比如list，set，dict等，也就是说这个对象有`不止一层内存地址`，非组合对象都是直接等号赋值。

- `浅拷贝`：**创建一个新的组合变量**，但是组合变量中每一个元素`指向`拷贝的对象内元素地址
- `深拷贝`：**创建一个新的组合变量**，原对象中的每个元素都会在新对象中`重新创建一次`

对于组合对象list，set，dict（没有tuple）自带copy浅拷贝方法，深拷贝需要导入`copy`模块，调用`deepcopy`方法，copy的copy方法对应浅拷贝。

```python
# 浅拷贝
>>> a = [1, 2, 3]
>>> b = a.copy()
>>> print(a is b)
False
>>> for i, j in zip(a, b):
...     print(id(i))
...     print(id(j))
...     print(i is j)
... 
93994145530624
93994145530624
True
93994145530656
93994145530656
True
93994145530688
93994145530688
True
```

可见，浅拷贝后新对象地址不一样，但是内部元素引用一致.

```python
>>> a = [1, 2, 3]
>>> import copy
>>> b = copy.deepcopy(a)
>>> print(a is b)
False
>>> for i, j in zip(a, b):
...     print(id(i))
...     print(id(j))
...     print(i is j)
... 
93994145530624
93994145530624
True
93994145530656
93994145530656
True
93994145530688
93994145530688
True
```

深拷贝新建了一个对象，但是内部元素也是引用的原始地址，**原因是内部元素是小整数，小整数在内存中有缓存直接调用**，换一下内部元素为可变对象。

```python
>>> a = [[1, 2], [2, 3], [3, 4]]
>>> b = copy.deepcopy(a)
>>> print(a is b)
False
>>> for i, j in zip(a, b):
...     print(id(i))
...     print(id(j))
...     print(i is j)
... 
140139841222048
140139840826496
False
140139841244208
140139840826816
False
140139841244128
140139840826976
False
```

深拷贝不仅对象，连对象内部的元素都重新创建，在用新数据试下浅拷贝.

```python
>>> a = [[1, 2], [2, 3], [3, 4]]
>>> b = copy.copy(a)
>>> print(a is b)
False
>>> for i, j in zip(a, b):
...     print(id(i))
...     print(id(j))
...     print(i is j)
... 
140139841222048
140139841222048
True
140139841244208
140139841244208
True
140139841244128
140139841244128
True
```

可见，浅拷贝只是创建新对象，内部元素还是老的引用。

如果我们对组合对象进行赋值操作，会是什么样结果？

```python
>>> a = [[1, 2], [2, 3], [3, 4]]
>>> b = a
>>> print(a is b)
True
>>> for i, j in zip(a, b):
...     print(id(i))
...     print(id(j))
...     print(i is j)
... 
140139841222048
140139841222048
True
140139841244208
140139841244208
True
140139841244128
140139841244128
True
```

可见赋值引用`所有地址全部拷贝`去了，既不要创建新对象，内部元素也全是来的对象内部元素的引用。

## 总结

- 赋值引用会之间将内存地址传递过去，此时变量间不仅`值相等`，`内存地址也相等`，是`同一个对象`。

- 分别赋值存在`缓存重用`的情况，当重复定义`小整数`和`字符串`变量时，或者在同一个代码块中，`内存中已经存在的值会直接被引用`，不需要重新创建对象。

- 组合变量存在`赋值引用`，`深拷贝`，`浅拷贝`三种模式，赋值引用将组合对象的每一层地址`全部引用`，浅拷贝创建新对象，但是`内部元素引用`旧对象的内部元素，深拷贝所有地址`全部重新创建`，不依赖之前任何的内存地址。

  

- 和原始对象的关系或者联系紧密程度：赋值引用 > = 浅拷贝 >= 深拷贝

- 内存的复用程度：赋值引用 > = 浅拷贝 >= 深拷贝

- 变量的崭新程度：深拷贝 >= 浅拷贝 >= 赋值引用

最后一个例子，对比一下组合对象的三种拷贝方式的区别：

```python
>>> a = [[1, 2], [2, 3], [3, 4]]
>>> for line in a:
...     line[1] = 9  # 直接拿到组合变量的内部元素进行修改
... 
>>> a
[[1, 9], [2, 9], [3, 9]]
>>> a = [[1, 2], [2, 3], [3, 4]]
>>> for line in a.copy():  # 生成一个新对象遍历，但是内部元素还是旧元素的引用，内部元素是list，地址没变，只是list的第二个值改了，因此也会对原对象产生影响
...     line[1] = 9
... 
>>> a
[[1, 9], [2, 9], [3, 9]]
>>> a = [[1, 2], [2, 3], [3, 4]]
>>> for line in copy.deepcopy(a):  # 创建新元素遍历，内部元素也是新创建的和之前没有任何关系，所以修改内部元素不会对原来变量造成影响
...     line[1] = 9
... 
>>> a
[[1, 2], [2, 3], [3, 4]]
```

## 参考

[Python中的引用赋值，深拷贝，浅拷贝](https://www.jianshu.com/p/5d8ec56b6d14)

[Python中List的复制（直接复制、浅拷贝、深拷贝](https://blog.csdn.net/qq_24502469/article/details/104185122)

