

# 算法笔记

## Motivation

此帖子用来记录 CV基础知识，对知识点的自我理解，采用问答形式去掌握核心

## 检测基础

### 1. 如何计算mAP?

<u>原理：掌握   代码：了解伪代码</u>

> **问题：**
>
> 1)   AP及mAP 计算过程？
>
> 2）PR曲线如何绘制的，怎么反应模型性能好坏的，怎么找到二者的平衡？
>
> 3)  为何PR曲线中precision 与recall成负相关？

#### **基础概念**：

**TP**：正确的检测的数量：正确分类且为正样本/前景（IOU >= threshold)

**FP**：错误的检测的数量：IOU <= threshold

**FN**: 漏检的数量

**TN**: 没有意义。因为我们只关注前景，不会去检测背景的框，没事找事啊

**Precision**: 反应模型找到正确检测框的能力
$$
precision = TP/(TP + FP) = TP/all-detections
$$
**Recall**:反应模型找到所有真实框的能力
$$
Recall = TP/(TP+FN) = TP/all-ground-truths
$$
**AP**: 平均精度，在不同recall下的最高precision的均值(一般会对各类别分别计算各自的AP)。

**mAP**:  平均精度的均值，各类别的AP的均值。

#### AP及mAP计算过程

ap是针对于一个类别，所以以下举其中一类的例子

**第一步：排序**

我们通过inference获得一批检测框(coordinate, score), 数量记作，然后按照类别划分，我们拿出其中一类的检测框，数量记作**n_dets**, 然后根据每个框的socre得分，降序排列，这样就得到一个序列（n_dets, score)。

**第二步：由IOU求TP、FP**

将每个检测框与GT做IOU计算，大于阈值即为TP，小于则为FP，此时已经可以计算出一组precision和recall

**第三步：动态计算precision&recall**

为啥说动态，因为我们调整score的阈值，从小到大依次累加，会影响检测框的总数，所以会得到不同组的precision和recall

这也是我们画PR曲线的基础

第四步：计算AP

如果按照[VOC07](https://arleyzhang.github.io/articles/1dc20586/)的AP计算标准，对于0.0-1.0的11个Recall阈值(间隔0.1），分别取每个阈值之上的最大precision进行计算平均值



