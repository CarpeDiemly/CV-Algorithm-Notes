## 问题

FPN网络的上采样过程用到了最近邻插值（转置卷积也是一种上采样方法，具体在其他问题中介绍），Mask R-CNN的 ROI Align 中用到了双线性插值，图像的resize也用到了，所以很重要！！！

## 背景知识

其实图像插值分为图像内插值和图像间插值两种。

**图像内插值**的主要应用是对图像进行放大以及旋转等操作，是从低分辨率的图像生成高分辨率图像的过程，用以恢复图像中丢失的信息，使得图像更清晰，细节信息更多，相邻像素之间的过渡更加有连续性。也就是单帧图像的图像重建过程。

而**图像间插值，也叫图像的超分辨率重建**，是指在一图像序列之间再生出若干幅新的图像，可应用于医学图像序列切片和视频序列之间的的插值。

我们这里主要讨论的是图像内插值，常用的图像内插值算法有：最近邻插值、双线性插值、三次内插法，简而言之，**就是用现有的像素去补齐缺失或多余的像素。**

## 最近邻插值

这是最简单的一种插值方法，不需要计算。算法是：在待求像素的四邻域中，将距离待求像素最近的邻像素的灰度值赋给待求像素。下面举个例子：如图所示，我们要求坐标为 $(i+u, j+v)$ 的像素灰度值，其中 i 和 j 为正整数，$0 < u, v < 1 $ 。

![img](https://p-blog.csdn.net/images/p_blog_csdn_net/coy_wang/EntryImages/20091217/最邻近元.png)

那么当  $(i+u, j+v)$ 落在 A 区时，即 $u < 0.5$ , $v < 0.5$ ，则将左上角的像素的灰度值赋给待求像素，其他区域同理。不过图中没有说明当 $u = 0.5$ 或者 $v = 0.5$ 的时候应该取那个值，这我们在写程序的时候自己定义就可以，赋哪边的值都差别不大。

这种方法计算量小，但可能会造成插值生成的图像灰度上的不连续，在灰度变化的地方可能会出现明显的锯齿感。

上面是在数字图像处理中，**遇到像素坐标为小数时的取值问题**，最开始我们也提到了 FPN 的从上往下的旁路中的上采样也使用到了最近邻插值方法，这里的上采样是使得特征图的宽与高变成原来的 2 倍，那跟我们这里提到的小数坐标运算问题不太一样，它是直接先逐行复制，再逐列复制，具体的表现我们使**用 keras 中的 UpSampling2D 函数**来可视化下就很清晰了：

```python
#!/usr/bin/env/python3
# _*_ coding = utf-8 _*_

from keras.layers import UpSampling2D
import numpy as np
import tensorflow as tf
x=np.array([1,2,3,4])
x=x.reshape(1,2,2,1)
x=tf.convert_to_tensor(x)
y=UpSampling2D(size=(2,2))(x)
with tf.Session() as sess:
    print(y.eval())
```

运行下这段代码就可以看到我们的输入为：
$$
\left[ \begin{matrix} 1 & 2\\ 3 & 4\end{matrix}\right ]
$$
输出为：
$$
\left[ \begin{matrix} 1 & 1 & 2 & 2\\ 1 & 1 & 2 & 2 \\ 3 & 3 & 4& 4 \\ 3 & 3 & 4& 4 \end{matrix}\right ]
$$

## 双线性插值

### 一维线性插值

假设我们已知坐标（x0,y0）与（x1,y1），要得到[x0,x1]区间内某一位置x在直线上的值。根据图中所示可得：

![image-20220818225126044](C:\Users\10428\AppData\Roaming\Typora\typora-user-images\image-20220818225126044.png)

通过斜率比，可以得以下等式：

$y-y_o/y_1-y_o = x-x_o/x_1-x_o$

如果令：

$\alpha=x-x_o/x_1 - x_0 $

则有：

$y = (1-\alpha)y_0 + \alpha y_1$

### 双线性插值

如图所示：所谓双线性插值，也就是连续使用三次一维线性插值，最终求得g(u0,v0)。
第一次：由g(u’,v’)和g(u’+1,v’)一维线性插值求g(u0,v’).
第二次：由g(u’,v’+1)和g(u’+1,v’+1)一维线性插值求g(u0,v’+1).
第三次：由g(u0,v’)和g(u0,v’+1)一维线性插值求g(u0,v0).

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200520192759829.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpdHQxZQ==,size_16,color_FFFFFF,t_70)

那么我们如何用双线性插值放大或收缩图像呢？我们需要做两件事：

1. 计算新图像素在原图像的对应位置，这里就会看到有小数的坐标
2. 通过位置，在原图中找到四个点来计算新图对应的位置的像素值

f(x,y)表示输出图像，g(u,v)表示输入图像。图像放大或缩小的几何运算可定义为：$f(x, y)=g(u_0, v_o) = g[a(x, y), b(x, y)]$.如果令$u_0 = a(x, y)=x/c, v_o=b(x,y)=y/d$. 我们知道$u_0, v_0$的坐标其实就是原图沿x轴放大c倍，y轴方向放大d倍。

![image-20220818230825651](https://raw.githubusercontent.com/kongyan66/Img-for-md/master/img/image-20220818230825651.png)

## 三次内插法

这个方法利用三次多项式求逼近理论上的最佳插值函数，待求像素 $(x,y)$ 的灰度值由其周围 16 个灰度值加权内插得到。计算公式有点小复杂，没那么直观。（这里就先参考博客里的记录一下，没太理解，需要了解的看看参考资料有简单介绍）

## 三者的比较

**效果**：最近邻插值算法 < 双线性插值 < 三次插值
**速度**：最近邻插值算法 > 双线性插值 > 三次插值

## 参考资料

[关于上采样方法总结（插值和深度学习）](https://blog.csdn.net/qq_34919792/article/details/102697817)
[常用的几种图像插值算法](https://blog.csdn.net/Du_Shuang/article/details/82463502)
[双线性插值的python实现](https://blog.csdn.net/litt1e/article/details/106242676)

