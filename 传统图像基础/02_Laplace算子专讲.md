

## 边缘检测

### 综述

边缘检测是图像处理和计算机视觉中，尤其是特征提取中的一个研究领域。图像边缘检测大幅度地减少了数据量，并且剔除了可以认为不相关的信息，保留了图像重要的结构属性。

图像边缘是图像最基本的特征，所谓**边缘**(Edge) 是指图像局部特性的不连续性。灰度或结构等信息的突变处称之为**边缘**。例如，灰度级的突变、颜色的突变,、纹理结构的突变等。边缘是一个区域的结束，也是另一个区域的开始，利用该特征可以分割图像。

有许多方法用于边缘检测，它们的绝大部分可以划分为两类：基于查找一类和基于零穿越的一类。

**基于查找的方法**通过寻找图像一阶导数中的最大和最小值来检测边界，通常是将边界定位在梯度最大的方向。

**基于零穿越的方法**通过寻找图像二阶导数零穿越来寻找边界，通常是Laplacian过零点或者非线性差分表示的过零点。

当然还有第三种例如被大规模使用的 **canny 算子**，这个会更加复杂些。

在检测物体边缘时，先对其轮廓点进行粗略检测，然后通过链接规则把原来检测到的轮廓点连接起来，同时也检测和连接遗漏的边界点及去除虚假的边界点。

### 数学基础

#### 离散函数

定义域是离散集合的函数，称为离散函数。

<img src="https://raw.githubusercontent.com/kongyan66/Img-for-md/master/img/image-20220808223451311.png" alt="image-20220808223451311" style="zoom: 67%;" />

#### 差分与二阶差分

一阶差分就是相邻两个离散值的差，

$f(x_i+h) - f(x_i)$: 向前差分，记号是$\Delta$, 常用形式。

$f(x_i) - f(x_i - h)$：向后差分，记作 $\nabla。$

$f(x_i + h) - f(x_i - h)$ ：中心差分。

套娃一样，二阶差分就是一切差分的差分，下面一张图反应了差分的计算过程：

<img src="https://raw.githubusercontent.com/kongyan66/Img-for-md/master/img/image-20220808224056959.png" alt="image-20220808224056959" style="zoom:67%;" />

#### 偏导数的差分形式

那么离散函数的导数怎么算呢？当然不再有那么多求导公式 而是最简单形式：离散函数的导数退化成了差分，一维一阶差分公式和二阶差分公式分别为：如图2所示：

![image-20220808224411506](https://raw.githubusercontent.com/kongyan66/Img-for-md/master/img/image-20220808224411506.png)

### Laplace(拉普拉斯)算子

#### 原理

差分和导数类似，可以反映变化的快慢。**对灰度不同的两个像素进行差分，得到的值就是两个像素的过渡急缓。**而过度急剧的地方，往往就是图像中物体的边缘，因此我们认为：**一阶差分可以检测边缘存在的可能性**。这是一阶差分在这里的实际意义。

那么如果是二阶差分呢？在物理学中，对于位移$\vec{x}$和时间$t$，一阶导数表示速度，二阶差分表示速度的导数加速度。同样的，在图像处理上，一阶差分表示相邻像素的过渡急缓，二阶差分就表示这种过度急缓的变化强弱，可能你还是不明白，没关系，我们会在下面进一步解释。

如果一阶差分就能检测边缘，我们为什么还要二阶差分呢？

我们看下面的图：

![1571899683933](https://raw.githubusercontent.com/kongyan66/Img-for-md/master/img/1298aa31-c969-4217-89ae-6c25a36995da.png)

这是一张从白到黑均匀渐变的图案，如果交给一阶差分来从上往下分析，会发现差分值一直都存在。于是一阶差分滤波器告诉你：这里全是边缘。但是这和我们的常识是不符的，因为虽然灰度变化了，但是变化的趋势却是均匀的。那么怎么样才能正确判断这是不是边缘呢？聪明的你应该想到了，**用二阶差分来看**，差分值一直是 0，说明变化是十分均匀的，说明边缘并不存在。因此，**二阶差分才是真能确定边缘的存在性**。

现在知道了它的作用，我们怎么计算二阶差分呢？显然的，对一阶差分再算一次差分就行了，具体的操作我们在上一节的表格里列过，用数学语言表达，对于 $x$ 的二阶偏差分就是：

<img src="https://raw.githubusercontent.com/kongyan66/Img-for-md/master/img/image-20220808225427442.png" alt="image-20220808225427442" style="zoom:80%;" />

令 $x=x-1$ 得：

![image-20220808225458052](https://raw.githubusercontent.com/kongyan66/Img-for-md/master/img/image-20220808225458052.png)

同理得到对$y$ 的二阶差分。故有：

![image-20220808225520066](https://raw.githubusercontent.com/kongyan66/Img-for-md/master/img/image-20220808225520066.png)

综合可得：

![image-20220808225542630](https://raw.githubusercontent.com/kongyan66/Img-for-md/master/img/image-20220808225542630.png)

这个东西就是**拉普拉斯掩膜重心系数**，简称**拉普拉斯算子**，以窗口（窗口的概念，见高斯滤波原理章节）中心元素为坐标原点，将窗口中各个元素带入，即可得到窗口的权重模板，也称核（Kernel）。

一个 8 邻域的窗口核如下：

![image-20220808231150613](https://raw.githubusercontent.com/kongyan66/Img-for-md/master/img/image-20220808231150613.png)

以此核进行滤波，即可对图像进行锐化。当然这个核会有很多变体，只要保证最小公约数是掩膜重心系数就好（提醒：结果中有负值部分，记得进行归一化，以免造成缺失）

#### 使用

将Laplace算子写成filter mask后，其操作大同小异于其他的空间滤波操作。将filter mask在原图上逐行移动，然后mask中数值与其重合的像素相乘后求和，赋给与mask中心重合的像素，对图像的第一，和最后的行和列无法做上述操作的像素赋值零，就得到了拉普拉斯操作结果。因为Laplace算子是二阶导数操作，其在强调图像素中灰度不连续的部分的同时也不在强调灰度值连续的部分。这样会产生一个具有很明显的灰度边界，但是没有足够特征的黑色背景。背景特征可以通过原图像与Laplace算子操作后的图像混合恢复。用公式：

![image-20220808203012697](https://raw.githubusercontent.com/kongyan66/Img-for-md/master/img/image-20220808203012697.png)

### 参考

[简单易懂地向你解释：离散函数，差分，二阶差分和 Laplacian 滤波原理](https://segmentfault.com/a/1190000020793403)

[Laplace(拉普拉斯)算子](https://www.cnblogs.com/raorao1994/p/8651276.html)



