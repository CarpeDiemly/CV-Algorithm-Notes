# 回溯小结
回溯算法用于搜索一个问题的所有的解 ，通过深度优先遍历的思想实现。

## 概述

首先我们对回溯需要有个清晰的认识，究竟什么是回溯呢？

**正经版解释**：其实人生就像一颗充满了分支的n叉树，你的每一个选择都会使你走向不同的路线，获得不同的结局。如果能重来，我要选李白~呸！说错了，如果能重来，我们就能回溯到以前，选择到最美好的结局。

**电影版解释：**《大话西游》里有这样的情节，至尊宝要对着「月光宝盒」喊一声「波若菠萝蜜」，时间就可以回到回去（所有的人物、事物都得一样，才能叫「回到过去」），他才能救人。这个道理其实和这里的「撤销选择」是一模一样的。只有撤销上一次的选择，重置现场，才能够回到 完全一样 的过去，再开始新的尝试才会是有效的。**理解回溯比较困难的是理解「回到过去」，现实世界里我们无法回到过去，但是在算法的世界里可以。**

**总结版解释**：从众多分支的路径中，找到符合结果的路径或路径集。

## 基本框架

首选我们需要把问题抽象为一颗`N叉树`，此时需要考虑树的宽度和高度，宽度就是我们可以选择的情况，高度就是我们需要的结果的路径长度。

根据递归的基本步骤：

> 1. 确定入参与返回值 即明确函数的功能
> 2. 确定递归停止条件
> 3. 单层递归逻辑

<img src="https://raw.githubusercontent.com/kongyan66/Img-for-md/master/img/image-20221003151807777.png" alt="image-20221003151807777" style="zoom:67%;" />

​																												图为1, 2, 3排列的全排列过程

废话不多说，直接上回溯算法框架，解决一个回溯问题，实际上就是一个决策树的遍历过程，站在回溯树的一个节点上，你只需要思考 3 个问题：

1、路径：也就是已经做出的选择。

2、选择列表：也就是你当前可以做的选择。

3、结束条件：也就是到达决策树底层，无法再做选择的条件。

```python
def backtrack(路径, 选择列表):
    if 满足结束条件:
        result.add(路径)
        return
    
    for 选择 in 选择列表:
        # 做选择
        将该选择从选择列表移除
        路径.add(选择)
        backtrack(路径, 选择列表)
        # 撤销选择
        路径.remove(选择)
        将该选择再加入选择列表
```

做题的时候，建议先画树形图 ，画图能帮助我们想清楚递归结构，想清楚如何剪枝。拿题目中的示例，想一想人是怎么做的，一般这样下来，这棵递归树都不难画出。在画图的过程中思考清楚：

- 分支如何产生；
- 题目需要的解在哪里？是在叶子结点、还是在非叶子结点、还是在从跟结点到叶子结点的路径？
- 哪些搜索会产生不需要的解的？例如：产生重复是什么原因，如果在浅层就知道这个分支不能产生需要的结果，应该提前剪枝，剪枝的条件是什么，代码怎么写？

> 但是必须说明的是，不管怎么优化，都符合回溯框架，而且时间复杂度都不可能低于 O(N!)，因为穷举整棵决策树是无法避免的。**这也是回溯算法的一个特点，不像动态规划存在重叠子问题可以优化，回溯算法就是纯暴力穷举，复杂度一般都很高**。

## 回溯与DFS

**回溯法** 采用试错的思想，它尝试分步的去解决一个问题。在分步解决问题的过程中，当它通过尝试发现现有的分步答案不能得到有效的正确的解答的时候，它将取消上一步甚至是上几步的计算，再通过其它的可能的分步解答再次尝试寻找问题的答案。回溯法通常用最简单的递归方法来实现，在反复重复上述的步骤后可能出现两种情况：

- 找到一个可能存在的正确的答案；
- 在尝试了所有可能的分步方法后宣告该问题没有答案。

**深度优先搜索** 是一种用于遍历或搜索树或图的算法。这个算法会 尽可能深 的搜索树的分支。当结点 v 的所在边都己被探寻过，搜索将 回溯 到发现结点 v 的那条边的起始结点。这一过程一直进行到已发现从源结点可达的所有结点为止。如果还存在未被发现的结点，则选择其中一个作为源结点并重复以上过程，整个进程反复进行直到所有结点都被访问为止。

「回溯算法」强调了「深度优先遍历」思想的用途，用一个 不断变化 的变量，在尝试各种可能的过程中，搜索需要的结果。强调了 回退 操作对于搜索的合理性。而「深度优先遍历」强调一种遍历的思想。

**总之，DFS天然适合作为回溯的实现方式，只需要加入判断解空间的条件即可。**

## 回溯与动规

> 回溯法：自顶向下、由大及小
> 动态规划：自底向上、由小及大

**相同点：**

用于求解多阶段决策问题。多阶段决策问题即：

- 求解一个问题分为很多步骤（阶段）。
- 每一个步骤（阶段）可以有多种选择。

**不同点：**

- 动态规划只需要求我们评估最优值是多少，最优值对应的具体解是什么并不要求。因此很适合应用于评估一个方案的效果；
- 回溯算法可以搜索到所有的方案（包括最优解），它本质上是一种遍历算法，时间复杂度很高。

## 剪枝与去重

**剪枝**就是立即停止不必要的递归，及时止损。

**去重**主要对遍历过的元素进行标记，又分为同层去重和同枝去重，在排列和组合问题中会遇到。

## 例题

### 一、全排列问题

力扣第 46 题「 [全排列](https://leetcode.cn/problems/permutations/)」就是给你输入一个数组 `nums`，让你返回这些数字的全排列。

我们在高中的时候就做过排列组合的数学题，我们也知道 `n` 个不重复的数，全排列共有 `n!` 个。那么我们当时是怎么穷举全排列的呢？

比方说给三个数 `[1,2,3]`，你肯定不会无规律地乱穷举，一般是这样：

先固定第一位为 1，然后第二位可以是 2，那么第三位只能是 3；然后可以把第二位变成 3，第三位就只能是 2 了；然后就只能变化第一位，变成 2，然后再穷举后两位……

其实这就是回溯算法，我们高中无师自通就会用，或者有的同学直接画出如下这棵回溯树：

<img src="https://labuladong.github.io/algo/images/backtracking/1.jpg" alt="img" style="zoom:67%;" />

只要从根遍历这棵树，记录路径上的数字，其实就是所有的全排列。**我们不妨把这棵树称为回溯算法的「决策树」**。

**为啥说这是决策树呢，因为你在每个节点上其实都在做决策**。比如说你站在下图的红色节点上：

<img src="https://labuladong.github.io/algo/images/backtracking/2.jpg" alt="img" style="zoom:67%;" />

你现在就在做决策，可以选择 1 那条树枝，也可以选择 3 那条树枝。为啥只能在 1 和 3 之中选择呢？因为 2 这个树枝在你身后，这个选择你之前做过了，而全排列是不允许重复使用数字的。

**现在可以解答开头的几个名词：`[2]` 就是「路径」，记录你已经做过的选择；`[1,3]` 就是「选择列表」，表示你当前可以做出的选择；「结束条件」就是遍历到树的底层叶子节点，这里也就是选择列表为空的时候**。

如果明白了这几个名词，可以把「路径」和「选择」列表作为决策树上每个节点的属性，比如下图列出了几个蓝色节点的属性：

<img src="https://labuladong.github.io/algo/images/backtracking/3.jpg" alt="img" style="zoom:67%;" />

**我们定义的 `backtrack` 函数其实就像一个指针，在这棵树上游走，同时要正确维护每个节点的属性，每当走到树的底层叶子节点，其「路径」就是一个全排列**。

**我们只要在递归之前做出选择，在递归之后撤销刚才的选择**，就能正确得到每个节点的选择列表和路径。

下面，直接看全排列代码：

```python
class Solution:
    def __init__(self):
        self.path = []
        self.result = []
        # 使用标志位
        self.used = []
    def permute(self, nums: List[int]) -> List[List[int]]:
        self.used = [False] * len(nums)
        self.backtracking(nums)
        return self.result
    # 1.确定入参与返回值
    def backtracking(self, nums):
        # 2.确定递归的终止条件
        if len(self.path) == len(nums):
            self.result.append(self.path.copy())
        # 3.确定单层搜索逻辑
        for i in range(len(nums)):
            # 若同一树枝使用过，就不能再用了  
            if self.used[i]:   # 与同层去重的区别之处 if i > 0 and nums[i-1] == nums[i] and not self.used[i-1]:  
                continue
            self.used[i] = True   # 这块与同层去重一样
            self.path.append(nums[i]) 
            self.backtracking(nums)
            self.used[i] = False # 回溯
            self.path.pop() # 回溯
```

我们这里稍微做了些变通，没有显式记录「选择列表」，而是通过 `used` 数组排除已经存在 `track` 中的元素，从而推导出当前的选择列表：

<img src="https://raw.githubusercontent.com/kongyan66/Img-for-md/master/img/6.jpg" alt="img" style="zoom:67%;" />

至此，我们就通过全排列问题详解了回溯算法的底层原理。当然，这个算法解决全排列不是最高效的，你可能看到有的解法连 `used` 数组都不使用，通过交换元素达到目的。但是那种解法稍微难理解一些，这里就不写了，有兴趣可以自行搜索一下。

但是必须说明的是，不管怎么优化，都符合回溯框架，而且时间复杂度都不可能低于 O(N!)，因为穷举整棵决策树是无法避免的。**这也是回溯算法的一个特点，不像动态规划存在重叠子问题可以优化，回溯算法就是纯暴力穷举，复杂度一般都很高**。

## 参考

[动态规划和回溯算法到底谁是谁爹？](https://labuladong.github.io/algo/3/27/84/) (讲的有点乱，但比较全)

[回溯法四步走](cnblogs.com/blknemo/p/12431911.html)(讲的很好，发现宝藏了)

[代码随想录-回溯算法理论基础](https://programmercarl.com/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html#%E5%9B%9E%E6%BA%AF%E6%B3%95%E6%A8%A1%E6%9D%BF)

[代码随想录-回溯算法结题框架](https://labuladong.github.io/algo/4/31/105/)