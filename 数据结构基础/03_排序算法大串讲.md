# 排序大串讲

## 快速排序
快速排序**核心思想**是先将一个元素排好序，然后再将剩下的元素排好序。算法平均复杂度为O(nlog n)，最差为$O(N^2)$(退化为冒泡排序),故快排是最不稳法定的排序算法。

代码框架如下，其实，快速排序就是一个二叉树的前序遍历。：
```python
def sort(nums, int low, int high):
    if low >= high:
        return 
    # 对nums[low:high]进行切分
    p = partition(nums, low, high)
    sort(nums, low, p - 1)
    sort(nums, p + 1, high)
```

快速排序的**核心**无疑是 partition 函数， partition 函数的作用是在 nums[lo..hi] 中寻找一个分界点 p，通过交换元素使得 nums[lo..p-1] 都小于等于 nums[p]，且 nums[p+1..hi] 都大于 nums[p]：

<img src="https://labuladong.github.io/algo/images/快速选择/1.jpeg" alt="img" style="zoom: 50%;" />

一个元素左边的元素都比它小，右边的元素都比它大，啥意思？不就是它自己已经被放到正确的位置上了吗？

**所以 `partition` 函数干的事情，其实就是把 `nums[p]` 这个元素排好序了**。一个元素被排好序了，然后呢？你再把剩下的元素排好序不就得了。

**从二叉树的视角，我们可以把子数组 `nums[lo..hi]` 理解成二叉树节点上的值，`sort` 函数理解成二叉树的遍历函数**。