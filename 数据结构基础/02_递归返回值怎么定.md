# 递归的返回值如何确定
在定一个递归函数时，返回值是我们首先要考虑的，但递归函数什么时候要有返回值，什么时候没有返回值，特别是有的时候递归函数返回类型为bool类型。这对中间逻辑处理十分重要。

## 递归的返回值
要不要返回值是看任务需要的，如果是`遍历问题`，比如只要保存路径，就没必要返回值，因为目的已经达到了，不需要呀;但对于`分解问题`，比如合并二叉树，我们需要返回一个节点去重新构建树的，这时候当然需要了呀，下面给出所有常见情况：
   1）如果需要搜索整棵二叉树且不用处理递归返回值，递归函数就不要返回值。（13.路径总和ii）
   2）如果需要搜索整棵二叉树且需要处理递归返回值，递归函数就需要返回值(值、节点等)。 （236. 二叉树的最近公共祖先）
   3）如果要搜索其中**一条**符合条件的路径，那么递归一定需要返回值(bool)，因为遇到符合条件的路径了就要及时返回。（112.路径总和）

## 实例
### 返回bool值 

- **112.路径之和**

  给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。

  我们要遍历从根节点到叶子节点的的路径看看总和是不是目标和, 只要找一条符合条件的路径，就要及时返回，所以递归函数需要返回值。

  <img src="https://raw.githubusercontent.com/kongyan66/Img-for-md/master/img/image-20220905112730952.png" alt="image-20220905112730952" style="zoom:67%;" />

  图中可以看出，遍历的路线，并不要遍历整棵树，所以递归函数需要返回值，可以用bool类型表示，代码如下：

  ```python 
  class Solution:
      def __init__(self):
          self.path = []
          
      def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:
          if not root:
              return False
          return self.recursion(root, targetSum)
           
      def recursion(self, node, targetSum):
          self.path.append(node.val)
          # 1.确定递归停止条件
          if not node.left and not node.right:
              if sum(self.path) == targetSum:
                  return True 
              else:
                  return False
          # 2.确定单层递归的逻辑
          # 因为终止条件是判断叶子节点，所以递归的过程中就不要让空节点进入递归了
          if node.left:
              # 递归函数是有返回值的，如果递归函数返回true，说明找到了合适的路径，应该立刻返回，停止所有递归
              if self.recursion(node.left, targetSum):
                  return True
              self.path.pop() # 回溯
          if node.right:
              if self.recursion(node.right, targetSum):
                  return True
              self.path.pop()
       
  ```

  

  ## 参考

  [如何判断递归的返回值](https://programmercarl.com/0112.%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C.html#%E9%80%92%E5%BD%92)