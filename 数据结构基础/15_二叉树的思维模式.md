## 问题

二叉树真的很神奇的，他既可以是一个数据结构，也可以看做问题的分解的可视化话结构，今天就来探讨下他所用到主要解题思路。

## 基本思路

先在开头总结一下，二叉树解题的思维模式分两类：

**1、是否可以通过遍历一遍二叉树得到答案**？如果可以，用一个 `traverse` 函数配合外部变量来实现，这叫「遍历」的思维模式。

**2、是否可以定义一个递归函数，通过子问题（子树）的答案推导出原问题的答案**？如果可以，写出这个递归函数的定义，并充分利用这个函数的返回值，这叫「分解问题」的思维模式。

无论使用哪种思维模式，你都需要思考：

> **如果单独抽出一个二叉树节点，它需要做什么事情？需要在什么时候（前/中/后序位置）做**？其他的节点不用你操心，递归函数会帮你在所有节点上执行相同的操作。

## 前中后序

### 1.**前中后序仅仅是遍历的顺序吗？**

我先甩给你几个问题，请默默思考 30 秒：

> 1、你理解的二叉树的前中后序遍历是什么，仅仅是三个顺序不同的 List 吗？
>
> 2、请分析，后序遍历有什么特殊之处？
>
> 3、请分析，为什么多叉树没有中序遍历？

答不上来，说明你对前中后序的理解仅仅局限于教科书，不过没关系，我用类比的方式解释一下我眼中的前中后序遍历。

首先，回顾一下 [学习数据结构和算法的框架思维](https://labuladong.github.io/algo/1/2/) 中说到的二叉树遍历框架： 

```python
def recursion(root):
    if not root:
        return
    # 前序位置
    recursion(root.left)
    # 中序位置
    recursion(root.right)
    # 后序位置
```

先不管所谓的中后序，单看`recursion`函数是干什么的？其实它就是一个能够遍历二叉树节点的一个函数，和遍历数据和链表并无本质上的区别：

```python
# 遍历数组
# 迭代法
def traverse(arr):
    for i in range(len(arr)):
# 递归法
def traverse(arr, i):
    if i == len(arr):
        return
    # 前序位置
    traverse(arr, i +1)
    # 后序位置
# 遍历单链表
# 迭代法
def traverse(head):
    while head:
        head = head.next
# 递归法
def traverse(head):
    if not head:
        return
    # 前序位置
    traverse(head.next)
    # 后序位置
```

单链表和数组的遍历可以是迭代的，也可以是递归的，**二叉树这种结构无非就是二叉链表**，由于没办法简单改写成迭代形式，所以一般说二叉树的遍历框架都是指递归的形式。

你也注意到了，只要是递归形式的遍历，都可以有前序位置和后序位置，分别在递归之前和递归之后。**所谓前序位置，就是刚进入一个节点（元素）的时候，后序位置就是即将离开一个节点（元素）的时候**，那么进一步，你把代码写在不同位置，代码执行的时机也不同：

<img src="https://labuladong.github.io/algo/images/二叉树收官/1.jpeg" alt="img" style="zoom:67%;" />

比如说，如果让你**倒序打印**一条单链表上所有节点的值，你怎么搞？实现方式当然有很多，但如果你对递归的理解足够透彻，可以利用后序位置来操作：

```python
def traverse(head):
    if not head:
        return
    # 前序位置
    traverse(head.next)
    # 后序位置
    print(head.val)
```

结合上面那张图，你应该知道为什么这段代码能够倒序打印单链表了吧，本质上是利用递归的堆栈帮你实现了倒序遍历的效果。那么说回二叉树也是一样的，只不过多了一个中序位置罢了。

**前中后序是遍历二叉树过程中处理每一个节点的三个特殊时间点**，绝不仅仅是三个顺序不同的 List：

> 前序位置的代码在刚刚进入一个二叉树节点的时候执行；
>
> 后序位置的代码在将要离开一个二叉树节点的时候执行；
>
> 中序位置的代码在一个二叉树节点左子树都遍历完，即将开始遍历右子树的时候执行。

上文的前中后序「位置」，就是要和大家常说的前中后序「遍历」有所区别：你可以在前序位置写代码往一个 List 里面塞元素，那最后得到的就是前序遍历结果；但并不是说你就不可以写更复杂的代码做更复杂的事，这样这块的功能就可以拓展了，而不是仅仅是遍历，而是加什么逻辑，就实现什么功能。

画成图，前中后序三个位置在二叉树上是这样（**前序位置的代码执行是自顶向下的，而后序位置的代码执行是自底向上的**）：

<img src="https://labuladong.github.io/algo/images/二叉树收官/2.jpeg" alt="img" style="zoom:50%;" />

**你可以发现每个节点都有「唯一」属于自己的前中后序位置**，所以我说前中后序遍历是遍历二叉树过程中处理每一个节点的三个特殊时间点。

这里你也可以理解为什么多叉树没有中序位置，因为二叉树的每个节点只会进行唯一一次左子树切换右子树，而多叉树节点可能有很多子节点，会多次切换子树去遍历，所以多叉树节点没有「唯一」的中序遍历位置。

通过以上的分析，可知**二叉树的所有问题，就是让你在前中后序位置注入巧妙的代码逻辑，去达到自己的目的，你只需要单独思考每一个节点应该做什么，其他的不用你管，抛给二叉树遍历框架，递归会在所有节点上做相同的操作**。

### 2.**后续遍历的特殊之处**

说后序位置之前，先简单说下中序和前序。

中序位置主要用在 BST(二叉搜索树) 场景中，你完全可以把 BST 的中序遍历认为是遍历有序数组。

前序位置本身其实没有什么特别的性质，之所以你发现好像很多题都是在前序位置写代码，实际上是因为我们习惯把那些对前中后序位置不敏感的代码写在前序位置罢了。

**你可以发现，前序位置的代码执行是自顶向下的，而后序位置的代码执行是自底向上的**.这不奇怪，因为本文开头就说了前序位置是刚刚进入节点的时刻，后序位置是即将离开节点的时刻。

**但这里面大有玄妙，意味着前序位置的代码只能从函数参数中获取父节点传递来的数据，而后序位置的代码不仅可以获取参数数据，还可以获取到子树通过函数返回值传递回来的数据**。

举具体的例子，现在给你一棵二叉树，我问你两个简单的问题：

1、如果把根节点看做第 1 层，如何打印出每一个节点所在的层数？

2、如何打印出每个节点的左右子树各有多少节点？

第一个问题可以这样写代码：

```python
def traverse(root, level):
    if not root:
        return 
    print(root, level)
    traverse(root.left, level + 1)
    traverse(root.right, level + 1)
traverse(root, 1)
```

第二个问题可以这样写代码：

```python
def traverse(root):
    if not root:
        return 0
    leftCount = traverse(root.left)
    rightCount = traverse(root.right)
    print(root, leftCount, rightCount)
    return leftCount + rightCount +1
```

这两个问题的根本区别在于：一个节点在第几层，你从根节点遍历过来的过程就能顺带记录；而以一个节点为根的整棵子树有多少个节点，你需要遍历完子树之后才能数清楚。结合这两个简单的问题，你品味一下后序位置的特点，只有后序位置才能通过返回值获取子树的信息。**那么换句话说，一旦你发现题目和子树有关，那大概率要给函数设置合理的定义和返回值，在后序位置写代码了**。



## 两种解题思路

==**遍历&分解**==

**二叉树题目的递归解法可以分两类思路，第一类是遍历一遍二叉树得出答案，第二类是通过分解问题计算出答案，这两类思路分别对应着 [回溯算法核心框架](https://labuladong.github.io/algo/4/31/105/) 和 [动态规划核心框架](https://labuladong.github.io/algo/3/25/69/)**。

力扣第 104 题「 [二叉树的最大深度](https://leetcode.cn/problems/maximum-depth-of-binary-tree/)」就是最大深度的题目，所谓最大深度就是根节点到「最远」叶子节点的最长路径上的节点数，比如输入这棵二叉树，算法应该返回 3：

![img](https://raw.githubusercontent.com/kongyan66/Img-for-md/master/img/tree.jpg)

**遍历思路**

可能我们最先想到的就是，遍历一遍二叉树，用一个外部变量记录每个节点所在的深度，取最大值就可以得到最大深度，然后实时更新最大的深度，**通过借助外部变量和遍历过程的结果，这就是典型的遍历思路**，实现代码如下：

```python
class Solution:
    def __init__(self):
        self.depth = 0
        self.res = 0

    def maxDepth(self, root: Optional[TreeNode]) -> int:
        self.recursion(root)
        return self.res

    def recursion(self, root):
        if not root:
            return
        self.depth += 1
        self.res = max(self.res, self.depth)
        self.recursion(root.left)
        self.recursion(root.right)
        self.depth -= 1
```

这个解法应该很好理解，但为什么需要在前序位置增加 `depth`，在后序位置减小 `depth`, 以及`res`应该放在哪呢？

因为前面说了，前序位置是进入一个节点的时候，后序位置是离开一个节点的时候，`depth` 记录当前递归到的节点深度，你把 `traverse` 理解成在二叉树上游走的一个指针，所以当然要这样维护。至于对 `res` 的更新，你放到前中后序位置都可以，只要保证在进入节点之后，离开节点之前（即 `depth` 自增之后，自减之前）就行了。

**分解思路**

我们也可以这么想：`当前节点的最大高度=左右子叶节点最大高度 + 1 `, 这样就是**分解问题计算答案的思路**。需要我们把问题抽象为一个子问题，类似递归的推导，也就是动规的来源。

```python
class Solution:
    def maxDepth(self, root: Optional[TreeNode]) -> int:
        return self.recursion(root)
    # 1.确定入参与返回值
    # 返回值就是当前节点的深度depth
    def recursion(self, node):
        # 2.确定终止条件
        # 此题有返回值，故终止的时候也要有返回值（空节点深度为0）
        if not node:
            return 0
        # 3.确定单层递归逻辑
        # 分别求左右子树的深度，至于为啥不需要判断节点是否存在了，不存在深度就为0呗
        left_depth = self.recursion(node.left)
        right_depth = self.recursion(node.right)
        # 这里需要注意下，是从当前节点往下看，所以最终深度需要+1
        return max(left_depth, right_depth) + 1
```

只要明确递归函数的定义，这个解法也不难理解，但为什么主要的代码逻辑集中在后序位置？

因为这个思路正确的核心在于，你确实可以通过子树的最大深度推导出原树的深度，所以当然要首先利用递归函数的定义算出左右子树的最大深度，然后推出原树的最大深度，主要逻辑自然放在后序位置 (**分解问题大多数处理逻辑都放在后续位置**)。

## 小结

综上，遇到一道二叉树的题目时的通用思考过程是：

**1、是否可以通过遍历一遍二叉树得到答案**？如果可以，用一个 `traverse` 函数配合外部变量来实现。

**2、是否可以定义一个递归函数，通过子问题（子树）的答案推导出原问题的答案**？如果可以，写出这个递归函数的定义，并充分利用这个函数的返回值。

**3、无论使用哪一种思维模式，你都要明白二叉树的每一个节点需要做什么，需要在什么时候（前中后序）做**。

## 参考

[东哥带你刷二叉树（纲领篇）](https://labuladong.github.io/algo/2/21/36/)

